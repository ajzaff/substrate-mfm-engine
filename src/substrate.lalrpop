use crate::ast::{Arg, File, Instruction, Metadata, Node};
use crate::base;
use crate::base::arith::U96;
use crate::base::{Const, Symmetries};
use enquote::unquote;
use std::str::FromStr;
use std::vec::Vec;

grammar;

Ident: &'input str = <s:r"[_a-z][_a-zA-Z0-9]*"> => s;

String: &'input str = <s:r#""[^"]*""#> => &s[1..s.len()-1];

BinNum: Const = <s:r"0b[01]+"> => Const::Unsigned(U96::from_str_radix(&s[2..], 2).unwrap());

DecNum: Const = <s:r"[1-9][0-9]+|[0-9]"> => Const::Unsigned(U96::from_str_radix(s, 10).unwrap());

HexNum: Const = <s:r"0x[0-9a-fA-F]+"> => Const::Unsigned(U96::from_str_radix(&s[2..], 16).unwrap());

SignedNum: Const = <s:r"[+-][1-9][0-9]+|[+-][0-9]"> => Const::Signed(U96::from_str_radix(s, 10).unwrap());

ConstExpr: Const = {
    BinNum,
    DecNum,
    HexNum,
    SignedNum,
}

Symmetry: Symmetries = {
    <s:r"NONE|000L|090L|R180L|R270L|R000R|R090R|R180R|R270R|ALL"> => Symmetries::from_str(s).unwrap(),
}

Symmetries: Symmetries = {
    <s:Symmetry> => s,
    <s:Symmetry> "|" <ss:Symmetries> => s | ss,
}

pub Metadata: Node<'input> = {
    ".name" <i:String> => Node::Metadata(Metadata::Name(i)),
    ".symbol" <i:String> => Node::Metadata(Metadata::Symbol(i)),
    ".desc" <i:String> => Node::Metadata(Metadata::Desc(i)),
    ".author" <i:String> => Node::Metadata(Metadata::Author(i)),
    ".license" <i:String> => Node::Metadata(Metadata::License(i)),
    <p:r".radius [0-4]"> => Node::Metadata(Metadata::Radius(u8::from_str(&p[8..]).unwrap())),
    ".bgcolor" <i:String> => Node::Metadata(Metadata::BgColor(i)),
    ".fgcolor" <i:String> => Node::Metadata(Metadata::FgColor(i)),
    ".symmetries" <s:Symmetries> => Node::Metadata(Metadata::Symmetries(s)),
    ".field" <i:Ident> "," <o:r"[1-9][0-9]+|[0-9]"> "," <n:r"[1-9][0-9]+|[0-9]"> => Node::Metadata(
        Metadata::Field(i, base::FieldSelector{
            offset: u8::from_str(o).unwrap(),
            length: u8::from_str(n).unwrap(),
        })),
    ".parameter" <i:Ident> "," <c:ConstExpr> => Node::Metadata(Metadata::Parameter(i, c)),
}

Label: Node<'input> = <i:Ident> ":" => Node::Label(i);

pub Instruction: Node<'input> = {
    "nop" => Node::Instruction(Instruction::Nop),
    "exit" => Node::Instruction(Instruction::Exit),
    "swapsites" => Node::Instruction(Instruction::SwapSites),
    "setsite" => Node::Instruction(Instruction::SetSite),
    "setfield" <i:Ident> => Node::Instruction(Instruction::SetField(Arg::Ast(i))),
    "setsitefield" <i:Ident> => Node::Instruction(Instruction::SetSiteField(Arg::Ast(i))),
    "getsite" => Node::Instruction(Instruction::GetSite),
    "getfield" <i:Ident> => Node::Instruction(Instruction::GetField(Arg::Ast(i))),
    "getsitefield" <i:Ident> => Node::Instruction(Instruction::GetSiteField(Arg::Ast(i))),
    "gettype" <i:String> => Node::Instruction(Instruction::GetType(Arg::Ast(i))),
    "getparameter" <i:Ident> => Node::Instruction(Instruction::GetParameter(Arg::Ast(i))),
    "scan" => Node::Instruction(Instruction::Scan),
    "savesymmetries" => Node::Instruction(Instruction::SaveSymmetries),
    "usesymmetries" <s:Symmetries> => Node::Instruction(Instruction::UseSymmetries(s)),
    "restoresymmetries" => Node::Instruction(Instruction::RestoreSymmetries),
    "push" <c:ConstExpr> => Node::Instruction(Instruction::Push(c)),
    "pop" => Node::Instruction(Instruction::Pop),
    "dup" => Node::Instruction(Instruction::Dup),
    "over" => Node::Instruction(Instruction::Over),
    "swap" => Node::Instruction(Instruction::Swap),
    "rot" => Node::Instruction(Instruction::Rot),
    "call" <i:Ident> => Node::Instruction(Instruction::Call(Arg::Ast(i))),
    "ret" => Node::Instruction(Instruction::Ret),
    "checksum" => Node::Instruction(Instruction::Checksum),
    "add" => Node::Instruction(Instruction::Add),
    "sub" => Node::Instruction(Instruction::Sub),
    "neg" => Node::Instruction(Instruction::Neg),
    "mod" => Node::Instruction(Instruction::Mod),
    "mul" => Node::Instruction(Instruction::Mul),
    "div" => Node::Instruction(Instruction::Div),
    "less" => Node::Instruction(Instruction::Less),
    "lessequal" => Node::Instruction(Instruction::LessEqual),
    "or" => Node::Instruction(Instruction::Or),
    "and" => Node::Instruction(Instruction::And),
    "xor" => Node::Instruction(Instruction::Xor),
    "equal" => Node::Instruction(Instruction::Equal),
    "bitcount" => Node::Instruction(Instruction::BitCount),
    "bitscanforward" => Node::Instruction(Instruction::BitScanForward),
    "bitscanreverse" => Node::Instruction(Instruction::BitScanReverse),
    "lshift" => Node::Instruction(Instruction::LShift),
    "rshift" => Node::Instruction(Instruction::RShift),
    "jump" <i:Ident> => Node::Instruction(Instruction::Jump(Arg::Ast(i))),
    "jumprelativeoffset" <i:Ident> => Node::Instruction(Instruction::JumpRelativeOffset(Arg::Ast(i))),
    "jumpzero" <i:Ident> => Node::Instruction(Instruction::JumpZero(Arg::Ast(i))),
    "jumpnonzero" <i:Ident> => Node::Instruction(Instruction::JumpNonZero(Arg::Ast(i))),
}

MetadataLine: Node<'input> = <v:Metadata> => v;

FileHeader: Vec<Node<'input>> = {
    <v:MetadataLine> => vec![v],
    <mut vs:FileHeader> <v:MetadataLine> => {
        vs.push(v);
        vs
    },
}

Comment: () = r"/\*.*\*/";

FileLine: Node<'input> = {
    <l:Label> Comment? => l,
    <i:Instruction> Comment? => i,
}

FileBody: Vec<Node<'input>> = {
    <v:FileLine> => vec![v],
    <mut vs:FileBody> <v:FileLine> => {
        vs.push(v);
        vs
    },
}

pub File: File<'input> = {
    <a:FileHeader> <b:FileBody?> => File{
        header: a,
        body: b.unwrap_or(vec![]),
    },
}