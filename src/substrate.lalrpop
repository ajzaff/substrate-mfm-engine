use crate::base;
use crate::base::arith::{U96, I96};
use crate::base::op::{Op, MetaOp};
use crate::base::{Const, Symmetries, SiteNumber};
use crate::ast;
use crate::ast::{Node, MetaArg, Arg, Args};
use std::str::FromStr;
use enquote::unquote;
use std::vec::Vec;

grammar;

Ident: String = <s:r"[_a-z][_a-zA-Z0-9]*"> => s.to_owned();

String: String = r#""[^"]*""# => unquote(<>).unwrap();

BinNum: Const = <s:r"0b[01]+"> => Const::Unsigned(U96::from_str_radix(&s[2..], 2).unwrap());

DecNum: Const = <s:r"[1-9][0-9]+|[0-9]"> => Const::Unsigned(U96::from_str_radix(s, 10).unwrap());

HexNum: Const = <s:r"0x[0-9a-fA-F]+"> => Const::Unsigned(U96::from_str_radix(&s[2..], 16).unwrap());

SignedNum: Const = <s:r"[+-][1-9][0-9]+|[+-][0-9]"> => Const::Signed(I96::from_str_radix(s, 10).unwrap());

ConstExpr: Const = {
    BinNum,
    DecNum,
    HexNum,
    SignedNum,
}

Symmetry: Symmetries = {
    <s:r"NONE|R000L|R090L|R180L|R270L|R000R|R090R|R180R|R270R|ALL"> => Symmetries::from_str(s).unwrap(),
}

Symmetries: Symmetries = {
    <s:Symmetry> => s,
    <s:Symmetry> "|" <ss:Symmetries> => s | ss,
}

pub MetaInstruction: Node = {
    ".name" <i:String> => Node::MetaInstruction(MetaOp::Name, MetaArg::String(i)),
    ".symbol" <i:String> => Node::MetaInstruction(MetaOp::Symbol, MetaArg::String(i)),
    ".desc" <i:String> => Node::MetaInstruction(MetaOp::Desc, MetaArg::String(i)),
    ".author" <i:String> => Node::MetaInstruction(MetaOp::Author, MetaArg::String(i)),
    ".license" <i:String> => Node::MetaInstruction(MetaOp::License, MetaArg::String(i)),
    <p:r".radius [0-4]"> => Node::MetaInstruction(MetaOp::Radius, MetaArg::Radius(u8::from_str(&p[8..]).unwrap())),
    ".bgcolor" <i:String> => Node::MetaInstruction(MetaOp::BgColor, MetaArg::String(i)),
    ".fgcolor" <i:String> => Node::MetaInstruction(MetaOp::FgColor, MetaArg::String(i)),
    ".symmetries" <ss:Symmetries> => Node::MetaInstruction(MetaOp::Symmetries, MetaArg::Symmetries(ss)),
    ".field" <i:Ident> "," <o:r"[1-9][0-9]+|[0-9]"> "," <n:r"[1-9][0-9]+|[0-9]"> => Node::MetaInstruction(
        MetaOp::Field,
        MetaArg::Field(i, base::FieldSelector{
            offset: u8::from_str(o).unwrap(),
            length: u8::from_str(n).unwrap(),
        })),
    ".parameter" <i:Ident> "," <c:ConstExpr> => Node::MetaInstruction(MetaOp::Parameter, MetaArg::Parameter(i, c)),
}

Label: Node = <i:Ident> ":" => Node::Label(i);

SiteNum: SiteNumber = <s:r"#40|#[1-3][0-9]|#[0-9]"> => SiteNumber(u8::from_str(&s[1..]).unwrap());

FieldRef: ast::Field = {
    "$" <i:Ident> => ast::Field::Ref(i),
}

TypeRef: Arg = {
    "%" <i:Ident> => Arg::Type(i),
    "%" <i:String> => Arg::Type(i),
}

RegisterRef: ast::Register = {
    "R?" => ast::Register::Random,
    <s:r"R[1-9][0-9]+|R[0-9]"> => ast::Register::R(usize::from_str(&s[1..]).unwrap()), 
}

Arg: Arg = {
    <i:SiteNum> <s:FieldRef> => Arg::SiteNumber(i, s),
    <i:SiteNum> => Arg::SiteNumber(i, ast::Field::Selector(base::FieldSelector::ALL)),
    <s:FieldRef> => Arg::SiteNumber(base::SiteNumber(0), s),
    <i:Ident> <s:FieldRef> => Arg::ConstRef(i, s),
    <i:Ident> => Arg::ConstRef(i, ast::Field::Selector(base::FieldSelector::ALL)),
    <t:TypeRef> => t,
    <r:RegisterRef> <s:FieldRef> => Arg::Register(r, s),
    <r:RegisterRef> => Arg::Register(r, ast::Field::Selector(base::FieldSelector::ALL)),
}

pub Instruction: Node = {
    "nop" => Node::Instruction(Op::Nop, Args::Null),
    "exit" => Node::Instruction(Op::Exit, Args::Null),
    "copy" <a:Arg> "," <b:Arg> => Node::Instruction(Op::Copy, Args::Binary(a, b)),
    "swap" <a:Arg> "," <b:Arg> => Node::Instruction(Op::Swap, Args::Binary(a, b)),
    "scan" <a:Arg> "," <b:Arg> => Node::Instruction(Op::Scan, Args::Binary(a, b)),
    "usesymmetries" <s:Symmetries> => Node::Instruction(Op::UseSymmetries, Args::Unary(Arg::Symmetries(s))),
    "restoresymmetries" => Node::Instruction(Op::RestoreSymmetries, Args::Null),
    "push" <a:Arg> => Node::Instruction(Op::Push, Args::Unary(a)),
    "pop" <a:Arg> => Node::Instruction(Op::Push, Args::Unary(a)),
    "call" <i:Ident> => Node::Instruction(Op::Call, Args::Unary(Arg::Label(i))),
    "ret" => Node::Instruction(Op::Ret, Args::Null),
    "checksum" <a:Arg> => Node::Instruction(Op::Checksum, Args::Unary(a)),
    "add" <a:Arg> "," <b:Arg> => Node::Instruction(Op::Add, Args::Binary(a, b)),
    "sub" <a:Arg> "," <b:Arg> => Node::Instruction(Op::Sub, Args::Binary(a, b)),
    "neg" <a:Arg> => Node::Instruction(Op::Neg, Args::Unary(a)),
    "mod" <a:Arg> "," <b:Arg> => Node::Instruction(Op::Mod, Args::Binary(a, b)),
    "mul" <a:Arg> "," <b:Arg> => Node::Instruction(Op::Mul, Args::Binary(a, b)),
    "div" <a:Arg> "," <b:Arg> => Node::Instruction(Op::Div, Args::Binary(a, b)),
    "less" <a:Arg> "," <b:Arg> => Node::Instruction(Op::Less, Args::Binary(a, b)),
    "lessequal" <a:Arg> "," <b:Arg> => Node::Instruction(Op::LessEqual, Args::Binary(a, b)),
    "or" <a:Arg> "," <b:Arg> => Node::Instruction(Op::Or, Args::Binary(a, b)),
    "and" <a:Arg> "," <b:Arg> => Node::Instruction(Op::And, Args::Binary(a, b)),
    "xor" <a:Arg> "," <b:Arg> => Node::Instruction(Op::Xor, Args::Binary(a, b)),
    "equal" <a:Arg> "," <b:Arg> => Node::Instruction(Op::Equal, Args::Binary(a, b)),
    "bitcount" <a:Arg> => Node::Instruction(Op::BitCount, Args::Unary(a)),
    "bitscanforward" <a:Arg> => Node::Instruction(Op::BitScanForward, Args::Unary(a)),
    "bitscanreserve" <a:Arg> => Node::Instruction(Op::BitScanReverse, Args::Unary(a)),
    "lshift" <a:Arg> "," <b:Arg> => Node::Instruction(Op::LShift, Args::Binary(a, b)),
    "rshift" <a:Arg> "," <b:Arg> => Node::Instruction(Op::RShift, Args::Binary(a, b)),
    "jump" <i:Ident> => Node::Instruction(Op::Jump, Args::Unary(Arg::Label(i))),
    "jumprelativeoffset" <i:Ident> "," <b:Arg> => Node::Instruction(Op::Jump, Args::Binary(Arg::Label(i), b)),
    "jumpzero" <i:Ident> "," <b:Arg> => Node::Instruction(Op::JumpZero, Args::Binary(Arg::Label(i), b)),
    "jumpnonzero" <i:Ident> "," <b:Arg> => Node::Instruction(Op::JumpNonZero, Args::Binary(Arg::Label(i), b)),
}

FileHeader: Vec<Node> = {
    <v:MetaInstruction> => vec![v],
    <mut vs:FileHeader> <v:MetaInstruction> => {
        vs.push(v);
        vs
    },
}

FileLine: Node = {
    Label,
    Instruction,
}

FileBody: Vec<Node> = {
    <v:FileLine> => vec![v],
    <mut vs:FileBody> <v:FileLine> => {
        vs.push(v);
        vs
    },
}

pub File: ast::File = {
    <a:FileHeader> <b:FileBody?> => ast::File{header: a, body: b.unwrap_or(vec![])},
}