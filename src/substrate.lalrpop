use crate::base;
use crate::base::arith::{U96, I96};
use crate::base::{Const, Symmetries, SiteNumber};
use crate::ast;
use crate::ast::{Node, Instruction, Metadata};
use std::str::FromStr;
use enquote::unquote;
use std::vec::Vec;

grammar;

Ident: String = <s:r"[_a-z][_a-zA-Z0-9]*"> => s.to_owned();

String: String = r#""[^"]*""# => unquote(<>).unwrap();

BinNum: Const = <s:r"0b[01]+"> => Const::Unsigned(U96::from_str_radix(&s[2..], 2).unwrap());

DecNum: Const = <s:r"[1-9][0-9]+|[0-9]"> => Const::Unsigned(U96::from_str_radix(s, 10).unwrap());

HexNum: Const = <s:r"0x[0-9a-fA-F]+"> => Const::Unsigned(U96::from_str_radix(&s[2..], 16).unwrap());

SignedNum: Const = <s:r"[+-][1-9][0-9]+|[+-][0-9]"> => Const::Signed(I96::from_str_radix(s, 10).unwrap());

ConstExpr: Const = {
    BinNum,
    DecNum,
    HexNum,
    SignedNum,
}

Symmetry: Symmetries = {
    <s:r"NONE|000L|090L|R180L|R270L|R000R|R090R|R180R|R270R|ALL"> => Symmetries::from_str(s).unwrap(),
}

Symmetries: Symmetries = {
    <s:Symmetry> => s,
    <s:Symmetry> "|" <ss:Symmetries> => s | ss,
}

pub Metadata: Node = {
    ".name" <i:String> => Node::Metadata(Metadata::Name(i)),
    ".symbol" <i:String> => Node::Metadata(Metadata::Symbol(i)),
    ".desc" <i:String> => Node::Metadata(Metadata::Desc(i)),
    ".author" <i:String> => Node::Metadata(Metadata::Author(i)),
    ".license" <i:String> => Node::Metadata(Metadata::License(i)),
    <p:r".radius [0-4]"> => Node::Metadata(Metadata::Radius(u8::from_str(&p[8..]).unwrap())),
    ".bgcolor" <i:String> => Node::Metadata(Metadata::BgColor(i)),
    ".fgcolor" <i:String> => Node::Metadata(Metadata::FgColor(i)),
    ".symmetries" <s:Symmetries> => Node::Metadata(Metadata::Symmetries(s)),
    ".field" <i:Ident> "," <o:r"[1-9][0-9]+|[0-9]"> "," <n:r"[1-9][0-9]+|[0-9]"> => Node::Metadata(
        Metadata::Field(i, base::FieldSelector{
            offset: u8::from_str(o).unwrap(),
            length: u8::from_str(n).unwrap(),
        })),
    ".parameter" <i:Ident> "," <c:ConstExpr> => Node::Metadata(Metadata::Parameter(i, c)),
}

Label: Node = <i:Ident> ":" => Node::Label(i);

pub Instruction: Node = {
    "nop" => Node::Instruction(Instruction::Nop),
    "exit" => Node::Instruction(Instruction::Exit),
    "swapsites" => Node::Instruction(Instruction::SwapSites),
    "setsite" => Node::Instruction(Instruction::SetSite),
    "setfield" <i:Ident> => Node::Instruction(Instruction::SetField(i)),
    "setsitefield" <i:Ident> => Node::Instruction(Instruction::SetSiteField(i)),
    "getsite" => Node::Instruction(Instruction::GetSite),
    "getfield" <i:Ident> => Node::Instruction(Instruction::GetField(i)),
    "getsitefield" <i:Ident> => Node::Instruction(Instruction::GetSiteField(i)),
    "gettype" <i:String> => Node::Instruction(Instruction::GetType(i)),
    "scan" => Node::Instruction(Instruction::Scan),
    "pushsymmetries" <s:Symmetries> => Node::Instruction(Instruction::PushSymmetries(s)),
    "popsymmetries" => Node::Instruction(Instruction::PopSymmetries),
    "push" <c:ConstExpr> => Node::Instruction(Instruction::Push(c)),
    "pop" => Node::Instruction(Instruction::Pop),
    "call" <i:Ident> => Node::Instruction(Instruction::Call(i)),
    "ret" => Node::Instruction(Instruction::Ret),
    "checksum" => Node::Instruction(Instruction::Checksum),
    "add" => Node::Instruction(Instruction::Add),
    "sub" => Node::Instruction(Instruction::Sub),
    "neg" => Node::Instruction(Instruction::Neg),
    "mod" => Node::Instruction(Instruction::Mod),
    "mul" => Node::Instruction(Instruction::Mul),
    "div" => Node::Instruction(Instruction::Div),
    "less" => Node::Instruction(Instruction::Less),
    "lessequal" => Node::Instruction(Instruction::LessEqual),
    "or" => Node::Instruction(Instruction::Or),
    "and" => Node::Instruction(Instruction::And),
    "xor" => Node::Instruction(Instruction::Xor),
    "equal" => Node::Instruction(Instruction::Equal),
    "bitcount" => Node::Instruction(Instruction::BitCount),
    "bitscanforward" => Node::Instruction(Instruction::BitScanForward),
    "bitscanreverse" => Node::Instruction(Instruction::BitScanReverse),
    "lshift" => Node::Instruction(Instruction::LShift),
    "rshift" => Node::Instruction(Instruction::RShift),
    "jump" <i:Ident> => Node::Instruction(Instruction::Jump(i)),
    "jumprelativeoffset" <i:Ident> => Node::Instruction(Instruction::JumpRelativeOffset(i)),
    "jumpzero" <i:Ident> => Node::Instruction(Instruction::JumpZero(i)),
    "jumpnonzero" <i:Ident> => Node::Instruction(Instruction::JumpNonZero(i)),
}

MetadataLine: Node = <v:Metadata> => v;

FileHeader: Vec<Node> = {
    <v:MetadataLine> => vec![v],
    <mut vs:FileHeader> <v:MetadataLine> => {
        vs.push(v);
        vs
    },
}

Comment: () = r"/\*.*\*/";

FileLine: Node = {
    <l:Label> Comment? => l,
    <i:Instruction> Comment? => i,
}

FileBody: Vec<Node> = {
    <v:FileLine> => vec![v],
    <mut vs:FileBody> <v:FileLine> => {
        vs.push(v);
        vs
    },
}

pub File: ast::File = {
    <a:FileHeader> <b:FileBody?> => ast::File{header: a, body: b.unwrap_or(vec![])},
}